# 体积分析

目前业内主流小程序平台都对小程序的代码包设置了严格的体积限制，微信是单包 2MB，总包 16MB，支付宝是单包 2MB，总包 8MB；包体积作为有限的资源，在小程序业务开发中异常重要，特别对于像滴滴出行这样的大型复杂业务。

Mpx 在包体积控制上做了很多工作，主要包括：
* [完善的分包支持](./subpackage.md#分包)
* [基于依赖声明的按需构建](./npm.md)
* [图像资源处理](./image-process.md)
* [公共样式复用](../basic/css.md#公共样式复用)

此外由于 Mpx 的编译构建完全基于 webpack，也能够直接复用webpack生态自带的代码压缩，模块复用，tree shaking，side effects 等能力对代码体积进行优化。

但是系统能做的工作终究有限，在一些人为不规范操作的影响下，最终输出的项目依然可能存在大量优化空间，比如在业务中不会被调用但无法被 tree shaking / side effects 移除的代码，因为 npm 依赖版本不统一造成的重复依赖，未经压缩的图像静态资源等，在大型项目中，这些问题想要被发现会非常困难，因此我们非常需要一个体积分析工具来管控项目体积和发现隐藏的体积问题。

## 与 webpack-bundle-analyzer 的区别

`webpack-bundle-analyzer` 提供了非常完善的体积分析和可视化展示能力，但是在 Mpx 构建输出小程序场景下，其所提供的能力还是有所缺失：
* 只能对 js 资源进行模块体积分析，而小程序的输出中包含了大量的非 js 静态资源，如 wxss / wxml / json 等，这些资源的体积都不会被统计分析；
* 没有针对某个分包进行体积分析的能力，由于小程序中存在对单一分包的体积限制，我们的体积往往会集中在主包和主要业务分包中，以分包维度进行体积分析的能力非常必要；
* 无法以特定的输入范围为维度进行体积的统计分析，这个能力诉求更多地出现在跨团队合作的复杂小程序当中，如滴滴出行。在这种场景下，接入合作的各方会更加关注己方引入的体积，并进行针对性地优化。

由于上述原因，我们在 Mpx@2.6.x 版本中提供了包体积分析能力，弥补了 `webpack-bundle-analyzer` 的能力缺失，为业务提供了便捷准确的包体积管控优化抓手。

## 使用方法

在 `@mpxjs/webpack-plugin` 配置中添加 `reportSize` 配置项即可使用，简单示例如下：

```js
new MpxWebpackPlugin({
  // ...
  reportSize: {
    // 配置阈值，此处代表总包体积阈值为 1MB，超出将会触发编译报错提醒，该报错不阻断构建
    threshold: '1MB',
    // 配置体积计算分组，以输入分组为维度对体积进行分析，当没有该配置时结果中将不会包含分组体积信息
    groups: [
      {
        name: 'vant',
        // 配置分组 entry 匹配规则，小程序中所有的页面和组件都可被视为 entry，如下所示的分组配置将计算项目中引入的 vant 组件带来的体积占用
        entryRules: {
          include: '@vant/weapp'
        }
      },
      {
        name: 'pageGroup',
        // 每个分组中可分别配置阈值
        threshold: '500KB',
        entryRules: {
          include: ['src/pages/index', 'src/pages/user']
        }
      },
      {
        name: 'someSdk',
        // 有的时候你可能希望计算纯 js 入口引入的体积（不包含组件和页面），这种情况下需要使用 noEntryModules 配置匹配规则
        noEntryModules: {
          include: 'src/lib/sdk.js'
        }
      }
    ]
  }
})
```



